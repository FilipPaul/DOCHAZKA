try:
    import os
    import datetime
    #import holidays
    from table_prepare import create_dictionary_for_table_widget
    import souhrn
    import subprocess
    import shutil
    import pickle
    import msaccessdb
    import traceback
    import win32com.client
    from calendar import monthrange
    #Automaticaly update files from QT designer
    #if os.path.exists("DochazkaUi.py"):
    #    os.remove("DochazkaUi.py")
    #bashCommand = "pyuic5 -o DochazkaUi.py DochazkaUi_in_tabs.ui"
    #os.system(bashCommand)

    #self.YAML config file
    import yaml
    import pprint as p

    #PyQT IMPORTS
    from DochazkaUi import Ui_MainWindow as DesignerUI
    from PyQt5 import QtCore, QtGui, QtWidgets
    from PyQt5.QtCore import  QTimer,QDate,QTime
    from PyQt5.QtWidgets import QTableWidget, QComboBox,QDateTimeEdit, QFileDialog

    #Another Imports (mySuper Class)
    from AutomateSuperPackage.AutomateSuperModule import SuperClass
    from new_record_main import MainWindowApp as NEW_RECORD
    from makeTableForPrint import makeTableForPrint
    from SD_to_ACCDB_loader import Synchro
    from attendanceToExcellPrinter import ToExcellFromSingleDays

    class GlobalTimes():
        doctor = datetime.timedelta()
        faults = 0
        from_last_month = datetime.timedelta()
        holliday = datetime.timedelta()
        meals = 0
        normal = datetime.timedelta()
        overall_time = datetime.timedelta()
        short_work_rides = datetime.timedelta()
        sick_days = datetime.timedelta()
        work_rides = datetime.timedelta()
        to_next_month = datetime.timedelta()
        overtime = datetime.timedelta()
        overall_hour = datetime.timedelta()
        from_previous_month = datetime.timedelta()
        time_plan_hours = datetime.timedelta()
        overral_with_transfer = datetime.timedelta()



        def resetAll(self):
            self.doctor = datetime.timedelta()
            self.faults = 0
            self.from_last_month = datetime.timedelta()
            self.holliday = datetime.timedelta()
            self.meals = 0
            self.normal = datetime.timedelta()
            self.overall_time = datetime.timedelta()
            self.short_work_rides = datetime.timedelta()
            self.sick_days = datetime.timedelta()
            self.work_rides = datetime.timedelta()
            self.to_next_month = datetime.timedelta()
            self.overall_hour = datetime.timedelta()
            self.overtime = datetime.timedelta()
            self.from_previous_month = datetime.timedelta()
            self.time_plan_hours = datetime.timedelta()
            self.overral_with_transfer = datetime.timedelta()


    class EachDay():
        def __init__(self, number_of_days) -> None:
            self.employeeTimes = {}
            self.employeeSummary = {}
            for i in range(number_of_days):
                self.employeeTimes[f"{i+1}"]= {
                    
                'Doktor': datetime.timedelta(0),
                'Dovolena': datetime.timedelta(0),
                'Nemoc': datetime.timedelta(0),
                'Normalni Doba': datetime.timedelta(seconds=21139),
                'Pochuzka': datetime.timedelta(0),
                'Prac Cesta': datetime.timedelta(0),
                'Jine': datetime.timedelta(0),
                'Oml Abs': 0,
                'Celkem s obědy': datetime.timedelta(0),
                'Oběd': 0,
                'Celkem bez obědů': datetime.timedelta(0),
                    } 

            #self.employeeSummary["Časový plán"] = 0
            #self.employeeSummary["Prevod z minulého měsíce"] = 0
            #self.employeeSummary["Prevod do dalšího měsíce"] = 0
            #self.employeeSummary["Celkový přesčas"] = 0
            #self.employeeSummary["Vyplatit"] = 0
                
            
            #p.pp(self.employeeTimes)
                


        

    class AlignDelegate(QtWidgets.QStyledItemDelegate):
        def initStyleOption(self, option, index):
            super(AlignDelegate, self).initStyleOption(option, index)
            option.displayAlignment = QtCore.Qt.AlignCenter

    class MainWindowApp(QtWidgets.QMainWindow):
        """ Main Window App """

        def __init__(self, *args, **kwargs):#args = multiple input variables, **kvargs multiple keyword variables (dictionaries, touOml Absples etc.)
            ################ INIT Function ##################
            super().__init__(*args, **kwargs)#super inherits all methods and properties from its parent  (QWIDGET classes)
            
            #LOAD CONFIG FILE
            with open('config.yaml', "r") as f:
                self.YAML = yaml.safe_load(f)
                f.close()

            #Load UI forms creaated in QTdDesigner
            self.ui = DesignerUI() #UI form generated by UI designe
            self.ui.setupUi(self)
            self.SC = SuperClass()
            self.current_cell_row = 0
            self.current_cell_column = 0
            #Update CSS styling, create lists of Ui elements, etc..
            self.initStyles()
            self.number_of_days_in_current_month = monthrange(int(self.ui.te_year_selection.text()),self.ui.cbox_month.currentIndex()+1)[1]

            self.global_ov = GlobalTimes()

            self.dict_of_STAV = {
                "SMAZÁNO" : "SMAZÁNO",
                "Prichod" : "IN",
                "Odchod" : "OUT",
                "Prac Cesta" : "OUT",
                "Doktor" : "OUT",
                "Obed" : "OUT",
                "Dovolena" : "SPECIAL",
                "Nemoc" : "SPECIAL",
                "Oml Abs" : "SPECIAL",
                "Jine" : "SPECIAL",
            }

            
            database_didnt_exist_flag = False
            if False == os.path.exists(self.YAML["ACCDB"]):
                msaccessdb.create(self.YAML["ACCDB"])
                database_didnt_exist_flag = True
        
            self.ACCES =self.SC.database.AccesDatabase
            self.ACCES.multipleCursors([self.YAML["ACCDB"]])

            self.SYNCHRONIZE = Synchro(ACCES = self.ACCES, YAML = self.YAML)

            if database_didnt_exist_flag:
                self.SYNCHRONIZE.storeDataIntoDatabase()

            self.current_TAG = ""
            self.current_Jmeno = ""
            self.current_Prijmeni = ""
            self.employee_summary_dict = {}
            SQL_query = ""


        
            


            #########CREATE or Update Log TABLE ######################
            self.createAndUpdateTable(self.ui.table_selection,"SELECT TAG,Jmeno,Prijmeni FROM tags",0)
            #self.ui.table_selection.hideColumn(0) #LOG_ID

            #self.createAndUpdateTable(self.ui.table_attendance,"SELECT Jmeno,Prijmeni,TAG,STAV,SAVED_TIME,EDIT FROM logs WHERE LOG_ID = '1';",0,"APPEND_COLLUMNS")
            self.ui.table_selection.itemClicked.connect(self.selectEmployee)
            #self.ui.table_attendance.cellClicked.connect(self.makeTransparent)
            self.ui.cbox_month.currentIndexChanged.connect(self.updateMonthAndYear)
            self.ui.te_year_selection.textChanged.connect(self.updateMonthAndYear)
            self.ui.te_cnt_meals.textChanged.connect(self.updateOV)
            self.ui.te_cnt_short_walks.textChanged.connect(self.updateOV)
            self.ui.pb_make_changes.clicked.connect(self.makeChanges)
            self.ui.pb_add_reccord.clicked.connect(self.newRecordFromUi)
            self.ui.pb_refresh.clicked.connect(self.refresh)
            self.ui.pb_download_to_db_from_SD.clicked.connect(self.synchronize)
        
            self.ui.tabWidget.currentChanged.connect(self.printAllEmployees)
            self.ui.pb_print_selected.clicked.connect(self.printSeletcedEmployee)
            self.EXCELL = ToExcellFromSingleDays(self.ACCES, self.YAML)
            self.ui.pb_make_excell_anomalies.clicked.connect(self.makeExcellAnomalies)
            self.ui.pb_make_excell_attendance.clicked.connect(self.makeExcellAttendance)
            self.ui.pb_transfer_pay.clicked.connect(self.toNextMonth)

            self.employees_dict = []
            self.hours_in_day = {}
            self.attendance_to_pickle_dict = {}
            self.employee_summary_dict = {}
            self.init_all_tables(default = 1)

            self.AddRecordTimer = QTimer()
            self.AddRecordTimer.timeout.connect(self.newRecordISR)
            self.ui.pb_save_hour_settings.clicked.connect(self.saveHourSettings)
            
            self.readSettings()
            index = self.ui.table_selection.model().index(0,2)
            self.ui.table_selection.selectionModel().select(index, QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Current)
            

        def closeEvent(self, event):
            print("CLOSING APP")
            self.AddRecordTimer.stop()
            #self.repairDatabase()

            event.accept()
            
        

        def repairDatabase(self):
            self.ACCES.closeConnection()
            oApp = win32com.client.Dispatch("Access.Application")
            backup_path = self.YAML["ACCDB"].replace(".accdb","_backup.accdb")
            print(oApp.compactRepair(self.YAML["ACCDB"], backup_path))
            os.remove(backup_path)
            print("Database repaired")
            oAPP = None

        def toNextMonth(self):
            self.Vyplatit()
            year = int(self.ui.te_year_selection.text())
            #create neccesesary tables if doesnt exists
            self.SYNCHRONIZE.createNewToNextMonthTable(str(year)) #current year
            self.SYNCHRONIZE.createNewToNextMonthTable(str(year-1)) #previous year for (leden)

            #update tonextMonth table values:
            value_to_set = self.ui.te_transfer_next_month.toPlainText()
            if value_to_set == "":
                value_to_set = 0
            query = f"UPDATE toNextMonth{year} SET {self.ui.cbox_month.currentText()} = '{value_to_set}'\
    WHERE JMENO = '{self.current_Jmeno}' AND PRIJMENI = '{self.current_Prijmeni}'"
            print(f"QUERY: {query}")
            self.ACCES.WriteQuery(query)
            self.ACCES.UpdateDatabase()


        def Vyplatit(self):
            year = int(self.ui.te_year_selection.text())
            #create neccesesary tables if doesnt exists
            self.SYNCHRONIZE.createNewVyplatitTable(str(year)) #current year
            #update tonextMonth table values:
            value_to_set = self.ui.te_pay_next_month.toPlainText()
            if value_to_set == "":
                value_to_set = 0
            query = f"UPDATE Vyplatit{year} SET {self.ui.cbox_month.currentText()} = '{value_to_set}'\
    WHERE JMENO = '{self.current_Jmeno}' AND PRIJMENI = '{self.current_Prijmeni}'"
            print(f"QUERY: {query}")
            self.ACCES.WriteQuery(query)
            self.ACCES.UpdateDatabase()  

        def readFromVyplatit(self): # and also from current month
            year = int(self.ui.te_year_selection.text())
            self.SYNCHRONIZE.createNewVyplatitTable(str(year)) #current year
            query = f"SELECT {self.ui.cbox_month.currentText()} FROM Vyplatit{year} WHERE JMENO = '{self.current_Jmeno}' AND PRIJMENI = '{self.current_Prijmeni}'"
            self.ACCES.WriteQuery(query)
            result = self.ACCES.ResultFromQuery()
            #print(f"Setting vyplatit to result: {result}")
            self.ui.te_pay_next_month.setText(str(result[0][0]))
            

        def readFromPreviousMonth(self): # and also from current month
            year = int(self.ui.te_year_selection.text())
            self.SYNCHRONIZE.createNewToNextMonthTable(str(year)) #current year
            self.SYNCHRONIZE.createNewToNextMonthTable(str(year-1)) #previous year for (leden)
            if self.ui.cbox_month.currentText() == "Leden":
                year_of_selection = year-1
                previous_month = "Prosinec"
            else:
                year_of_selection = year
                previous_index = self.ui.cbox_month.currentIndex() -1
                previous_month = self.ui.cbox_month.itemText(previous_index)

            query = f"SELECT {previous_month} FROM toNextMonth{year_of_selection} WHERE JMENO = '{self.current_Jmeno}' AND PRIJMENI = '{self.current_Prijmeni}'"

            self.ACCES.WriteQuery(query)
            result = self.ACCES.ResultFromQuery()
            self.ui.la_transfer_last_month_num.setText(str(result[0][0]))

            #also read from current month
            year = int(self.ui.te_year_selection.text())
            query = f"SELECT {self.ui.cbox_month.currentText()} FROM toNextMonth{year} WHERE JMENO = '{self.current_Jmeno}' AND PRIJMENI = '{self.current_Prijmeni}'"
            
            self.ACCES.WriteQuery(query)
            result = self.ACCES.ResultFromQuery()
            self.ui.te_transfer_next_month.setPlainText(str(result[0][0]))

        def makeExcellAnomalies(self):
            self.EXCELL.data = self.hours_in_day
            self.EXCELL.month = self.ui.cbox_month.currentIndex()+1

            save_file,second_arg = QFileDialog.getSaveFileName(self, 'Save file',
            f'{self.ui.te_year_selection.text()}_{self.ui.cbox_month.currentText()}_anomalie',"(*.xlsx)")

            if ".xlsx" not in second_arg: 
                return
            
            self.EXCELL.path = save_file
            self.EXCELL.employee_Summary = self.employee_summary_dict
            self.EXCELL.printToExcell()

        def makeExcellAttendance(self):
            self.EXCELL.table_data = self.getRowValues()
            print(f"EXCELL DATA: {self.EXCELL.data}")
            self.EXCELL.month = self.ui.cbox_month.currentIndex()+1

            save_file,second_arg = QFileDialog.getSaveFileName(self, 'Save file',
            f'{self.ui.te_year_selection.text()}_{self.ui.cbox_month.currentText()}_dochazka',"(*.xlsx)")

            if ".xlsx" not in second_arg: 
                return
            
            self.EXCELL.path = save_file
            self.EXCELL.printTableToExcell()

        def savePplToPickle(self):
            print(f"PICKLE: {self.current_Jmeno} {self.current_Prijmeni}")
            with open(f"Dochazka{self.ui.cbox_month.currentText()}.pkl", "wb") as f:
                pickle.dump(self.hours_in_day,f)
                f.close()

            attendance_dict = self.getRowValues()
            with open(f"Dochazka_table_{self.ui.cbox_month.currentText()}.pkl", "wb") as f:
                pickle.dump(attendance_dict,f)
                f.close()


        def getRowValues(self) -> dict:  # gets the row values
            self.attendance_to_pickle_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"] = {}
            header_cnt = self.ui.table_attendance.horizontalHeader().count()
            for headerIndex in range(header_cnt):
                print(self.ui.table_attendance.horizontalHeaderItem(headerIndex).text())
                self.attendance_to_pickle_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"][self.ui.table_attendance.horizontalHeaderItem(headerIndex).text()] = []
                for row in range(self.ui.table_attendance.rowCount()):
                    self.attendance_to_pickle_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"][self.ui.table_attendance.horizontalHeaderItem(headerIndex).text()].append(self.ui.table_attendance.item(row,headerIndex).text())
            return self.attendance_to_pickle_dict


        def readSettings(self):
            if self.SYNCHRONIZE.tableAlreadyExists("SETTINGS",0):
                self.ACCES.WriteQuery(f"SELECT cnt_meals, cnt_short_walks, cnt_overtime FROM SETTINGS")
                result = self.ACCES.ResultFromQuery()
                self.ui.te_cnt_meals.setValue(float(result[0][0].replace(",",".")))
                self.ui.te_cnt_short_walks.setValue(float(result[0][1].replace(",",".")))
                #self.ui.te_cnt_overtime.setValue(float(result[0][2].replace(",",".")))
                #print(result)

            else:
                self.ACCES.WriteQuery(f"CREATE TABLE SETTINGS (cnt_meals TEXT, cnt_short_walks TEXT)")
                self.ACCES.WriteQuery(f"INSERT INTO SETTINGS (cnt_meals, cnt_short_walks) VALUES ('{self.ui.te_cnt_meals.text()}','{self.ui.te_cnt_short_walks.text()}')")
            
            self.ACCES.UpdateDatabase()

        def saveHourSettings(self):
                self.ACCES.WriteQuery(f"UPDATE SETTINGS SET cnt_meals = '{self.ui.te_cnt_meals.text()}', cnt_short_walks = '{self.ui.te_cnt_short_walks.text()}'")
                print("Saving hour settings")
                #print(f"{self.ui.te_cnt_meals.text()}")
                #print(f"{self.ui.te_cnt_short_walks.text()}")

                self.ACCES.UpdateDatabase()

        def synchronize(self):
            self.ui.pb_download_to_db_from_SD.setText("Synchronizing...")
            self.ui.pb_download_to_db_from_SD.repaint()
            self.SYNCHRONIZE.storeDataIntoDatabase()
            self.refresh()
            self.ui.la_last_log_ID_db_value.setText(str(self.SYNCHRONIZE.last_ID_in_database))
            self.ui.la_last_log_ID_SD_value.setText(str(self.SYNCHRONIZE.last_ID_in_SD))
            self.ui.pb_download_to_db_from_SD.setText("Synchronizovat s SD kartou")
        
        def refresh(self):
            self.ui.pb_refresh.setText("Refreshing...")
            self.ui.pb_refresh.repaint()
            self.updateMonthAndYear(None,1)
            self.ui.pb_refresh.setText("REFRESH")

        def timeDeltaToHours(self,td :datetime.timedelta):
            seconds = td.total_seconds()
            sign = ""
            if seconds < 0:
                sign = "-"
            seconds = abs(seconds)

            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            seconds = seconds % 60
            str_td = f"{sign}{int(hours):02d}:{int(minutes):02d}"
            return str_td

        def timeDeltaToHoursOnly(self,td :datetime.timedelta):
            seconds = td.total_seconds()
            sign = ""
            if seconds < 0:
                sign = "-"
            seconds = abs(seconds)
            hours = seconds / 3600
            str_td = f"{sign}{hours:.2f}h"
            return str_td

        def printSeletcedEmployee(self):

            save_file,second_arg = QFileDialog.getSaveFileName(self, 'Save file',
            f'Dochazka_{self.current_Jmeno}_{self.current_Prijmeni}_{self.ui.cbox_month.currentText()}',"(*.pdf)")

            if ".pdf" not in second_arg: 
                return

            if self.current_TAG in self.YAML["POLOVICNI_UVAZKY"]:
                uvazek = "poloviční"
            else:
                uvazek = "plný" 
            replacements = {
            "JMENO" : self.current_Jmeno,
            "PRIJMENI" : self.current_Prijmeni,
            "MESIC": self.ui.cbox_month.currentText(),
            "ROK": self.ui.te_year_selection.text(),
            "OSOBNICISLO": "X",
            "UVAZEK": uvazek,
            "PLANHOD": f"{self.timeDeltaToHoursOnly(self.global_ov.time_plan_hours)} bez obědů, {self.timeDeltaToHours(self.global_ov.time_plan_hours + datetime.timedelta(hours=0.5* int(str(self.global_ov.time_plan_hours/8)[:2])))} s obědy",
            "PLANDNY": f"{self.global_ov.time_plan_hours/8}"[:2],
            "NORMAL" : f"{self.timeDeltaToHoursOnly(self.global_ov.normal)} ({self.timeDeltaToHours(self.global_ov.normal)})",
            "DOVOLENA" : f"{self.timeDeltaToHoursOnly(self.global_ov.holliday)} ({self.timeDeltaToHours(self.global_ov.holliday)})",
            "NEMOC" : f"{self.timeDeltaToHoursOnly(self.global_ov.sick_days)} ({self.timeDeltaToHours(self.global_ov.sick_days)})",
            "LEKAR" : f"{self.timeDeltaToHoursOnly(self.global_ov.doctor)} ({self.timeDeltaToHours(self.global_ov.doctor)})",
            "PREDCHOZI" : f"{self.ui.la_transfer_last_month_num.text()} ({self.timeDeltaToHours(datetime.timedelta(hours=float(self.ui.la_transfer_last_month_num.text().replace(',','.'))))})",
            "PRACCESTY" : f"{self.timeDeltaToHoursOnly(self.global_ov.work_rides)} ({self.timeDeltaToHours(self.global_ov.work_rides)})",
            "POCHUZKY" : f"{self.timeDeltaToHoursOnly(self.global_ov.short_work_rides)} ({self.timeDeltaToHours(self.global_ov.short_work_rides)})",
            #"PRESCAS" : self.global_ov.overtime,
            "PRESCAS" :f"{self.timeDeltaToHoursOnly(self.global_ov.overall_hour - datetime.timedelta(hours=0.5*self.global_ov.meals) - self.global_ov.time_plan_hours)} ({self.timeDeltaToHours(self.global_ov.overall_hour - datetime.timedelta(hours=0.5*self.global_ov.meals) - self.global_ov.time_plan_hours)})",
            "OVERTIMWITHTRANSFER" :self.ui.la_ov_overtime.text(),
            "OBEDY" : self.global_ov.meals,
            "DALSI" : f"{self.ui.te_transfer_next_month.toPlainText()}h ({self.timeDeltaToHours(datetime.timedelta(hours=float(self.ui.te_transfer_next_month.toPlainText().replace(',','.').replace('h',''))))})",
            "VYPLAT" : f"{self.ui.te_pay_next_month.toPlainText()}h ({self.timeDeltaToHours(datetime.timedelta(hours=float(self.ui.te_pay_next_month.toPlainText().replace(',','.').replace('h',''))))})",
            "CELKEM" : f"{self.ui.la_transfer_current_month_num.text()} ({self.timeDeltaToHours(datetime.timedelta(hours=float(self.ui.la_transfer_current_month_num.text().replace(',','.').replace('h',''))))})",
            "CELKEMPREVOD" : f"{self.timeDeltaToHoursOnly(self.global_ov.overral_with_transfer)} ({self.timeDeltaToHours(self.global_ov.overral_with_transfer)})",
            }



            table_string = makeTableForPrint(self.ui.table_attendance)
            with open(R"tex_documents\personal_overview.tex","r", encoding="utf-8") as f:
                tex_file = f.read()
                
                for key in replacements:
                    if type(replacements[key]) == datetime.timedelta:
                        tex_file = tex_file.replace(key, f"{replacements[key].total_seconds()/3600:0.2f}")
                    else:
                        tex_file = tex_file.replace(key,str(replacements[key]))
                
                tex_file = tex_file.replace("MAINTABLE",table_string)
                f.close()

            with open(R"tex_documents\tex_trials\output.tex", "w", encoding="utf-8") as f:
                f.write(tex_file)
                f.close()



            cmd = ['pdflatex', '-interaction', 'nonstopmode', 'output.tex']
            proc = subprocess.Popen( cmd, cwd= "tex_documents/tex_trials")
            proc.communicate()

            retcode = proc.returncode
            if not retcode == 0:
                os.unlink("tex_documents/tex_trials/output.tex")
                raise ValueError('Error {} executing command: {}'.format(retcode, ' '.join(cmd))) 

            os.unlink("tex_documents/tex_trials/output.tex")
            os.unlink("tex_documents/tex_trials/output.log")

            shutil.copyfile("tex_documents/tex_trials/output.pdf", save_file)
            subprocess.Popen([save_file],shell=True)
            
        def printAllEmployees(self):
            if self.ui.tabWidget.currentIndex() == 2: #SOUHRN TAB
                souhrn.makeOverview(self.ui.table_souhrn,self.employees_dict)

        def newRecordFromUi(self):
            self.AddRecordWindow = NEW_RECORD(self.current_Jmeno,self.current_Prijmeni)
            self.AddRecordWindow.show()
            self.AddRecordTimer.start(200)

        def newRecordISR(self):
            if self.AddRecordWindow.ready_flag:
                self.AddRecordTimer.stop()
                last_LOG_ID = self.getLastLogID()
                sql_query = f"\
    INSERT INTO logs (LOG_ID, Jmeno, Prijmeni, TAG, STAV, SAVED_TIME, SAVED_DATE, EDIT) \
    VALUES ('E{last_LOG_ID + 1}','{self.current_Jmeno}','{self.current_Prijmeni}','{self.current_TAG}', '{self.AddRecordWindow.edit_state}',\
    #1/1/1900 {self.AddRecordWindow.edit_time.toString()}# ,#{self.AddRecordWindow.edit_date.toPyDate().isoformat()}#, 'EDITED');"
                print(sql_query)

                self.ACCES.MultipleWriteQuery(sql_query,[0])
                self.ACCES.MultipleUpdateDatabase([0])
                self.updateMonthAndYear(None,0)
                self.AddRecordWindow.close()

        def makeChanges(self):
            change_STAV = {}
            change_time = {}
            STAV_new_record_counter = 0
            time_new_record_counter = 0
            delete_count = 0
            for widgets in self.list_of_all_widgets_cboxes:
                if widgets.update_flag == 1:
                
                    #r = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{int(year)+1}-{1}-1 00:00:00#"
                    SAVED_DATE = datetime.datetime.strptime(self.ui.table_attendance.item(widgets.row,0).text()[3:13],"%d.%m.%Y")
                    SAVED_DATE = datetime.datetime.strftime(SAVED_DATE,"#%m/%d/%Y#")
                    sql_query = f"SELECT ID FROM logs WHERE STAV = '{self.ui.table_attendance.item(widgets.row,widgets.column).text()}'\
    AND SAVED_DATE = {SAVED_DATE} AND SAVED_TIME = #1/1/1900 {self.ui.table_attendance.item(widgets.row,widgets.column+1).text()}# AND TAG = '{self.current_TAG}'"
                    print(sql_query)
                    self.ACCES.MultipleWriteQuery( sql_query,[0])
                    result = self.ACCES.MultipleResultFromQuery([0])
                    if len(result) == 0:
                        change_STAV[f"NEW_RECORD_{STAV_new_record_counter}"] = [datetime.datetime.strptime(self.ui.table_attendance.item(widgets.row,0).text()[3:13],"%d.%m.%Y"), self.ui.table_attendance.cellWidget(widgets.row,widgets.column+1).text(), widgets.currentText()]
                        STAV_new_record_counter += 1
                    else:
                        if widgets.currentText() == "SMAZAT":
                            change_STAV[f"SMAZAT_{delete_count}"] = result[0][0]
                            delete_count += 1

                        else:
                            change_STAV[f"ID_{result[0][0]}"] = widgets.currentText()
                        #print(result[0][0])
                    print(f"ROW: {widgets.row}, COL: {widgets.column} -> from {self.ui.table_attendance.item(widgets.row,widgets.column).text()} to {widgets.currentText()}")


            
            for widgets in self.list_of_all_widgets_times:

                if widgets.update_flag == 1:
                    SAVED_DATE = datetime.datetime.strptime(self.ui.table_attendance.item(widgets.row,0).text()[3:13],"%d.%m.%Y")
                    SAVED_DATE = datetime.datetime.strftime(SAVED_DATE,"#%m/%d/%Y#")
                    sql_query = f"SELECT ID FROM logs WHERE STAV = '{self.ui.table_attendance.item(widgets.row,widgets.column-1).text()}'\
    AND SAVED_DATE = {SAVED_DATE} AND SAVED_TIME = #1/1/1900 {self.ui.table_attendance.item(widgets.row,widgets.column).text()}# AND TAG = '{self.current_TAG}'"
                    #print(sql_query)
                    self.ACCES.MultipleWriteQuery( sql_query,[0])
                    result = self.ACCES.MultipleResultFromQuery([0])
                    if len(result) == 0:
                        #print("new record")
                        change_time[f"NEW_RECORD_{time_new_record_counter}"] = [datetime.datetime.strptime(self.ui.table_attendance.item(widgets.row,0).text()[3:13],"%d.%m.%Y"), widgets.text(), self.ui.table_attendance.cellWidget(widgets.row, widgets.column-1).currentText()]
                        time_new_record_counter += 1
                    else:
                        #print(result[0][0])
                        #QDateTimeEdit().text
                        change_time[f"ID_{result[0][0]}"] = widgets.text()
                        
            #p.pprint(f"CHANGE TIME {change_time}") 
            #p.pprint(f" CHANGE STAV {change_STAV}")
            last_LOG_ID = self.getLastLogID()
            for keys_stav in change_STAV:
                #print(keys_stav)
                
                if str(keys_stav).find("SMAZAT") > -1:
                    sql_query_stav = f"UPDATE logs SET EDIT = 'SMAZÁNO' WHERE ID = {change_STAV[keys_stav]}"
                
                elif str(keys_stav).find("ID") > -1:
                    last_LOG_ID += 1
                    sql_query_stav = f"UPDATE logs SET STAV = '{change_STAV[keys_stav]}', EDIT = 'EDITED' WHERE ID = {keys_stav[3:]}"
                    
                else:
                    last_LOG_ID += 1
                    sql_query_stav = f"\
    INSERT INTO logs (LOG_ID, Jmeno, Prijmeni, TAG, STAV, SAVED_TIME, SAVED_DATE, EDIT) \
    VALUES ('E{last_LOG_ID}','{self.current_Jmeno}','{self.current_Prijmeni}','{self.current_TAG}', '{change_STAV[keys_stav][2]}',\
    #1/1/1900 {change_STAV[keys_stav][1]}# ,#{change_STAV[keys_stav][0]}#, 'EDITED');"

                    if change_STAV[keys_stav][2] == "SMAZAT":
                        #print("TRYING TO DELETE SOMETHING THAT DOESNT EXIST! nebuď debil a nemzej neexistující!!! ", keys_stav)
                        continue

                self.ACCES.MultipleWriteQuery(sql_query_stav,[0])

            for keys_time in change_time:
                if keys_time.find("ID") > -1:
                    sql_query_time = f"UPDATE logs SET SAVED_TIME = #1/1/1900 {change_time[keys_time]}# , EDIT = 'EDITED' WHERE ID = {keys_time[3:]}"
                    #print(sql_query_time)
                    self.ACCES.MultipleWriteQuery(sql_query_time,[0])
                
            self.ACCES.MultipleUpdateDatabase([0])
            self.updateMonthAndYear(None,0)
                #self.ACCES.MultipleWriteQuery(f"UPDATE logs SET STAV = {change_STAV[keys_stav]} WHERE ID = {keys_stav[4:]}")       
        
        def makeTransparent(self,item):
            item.setSelected(False)

        def table(self):
            pos = QtGui.QCursor.pos()
            print(pos)

        def updateOV(self):
            self.updateMonthAndYear(None,0)

        def mousePressEvent(self, event):
            if event.button() == QtCore.Qt.LeftButton:
                pos = QtGui.QCursor.pos()
                print(pos)
                pressed_cell = self.ui.table_attendance.indexAt(pos)
                print(pressed_cell.row(),pressed_cell.column())

        def updateMonthAndYear(self,index, default = 1):
            self.number_of_days_in_current_month = monthrange(int(self.ui.te_year_selection.text()),self.ui.cbox_month.currentIndex()+1)[1]
            print(f"SENDER IS: {self.sender()} default is: {default}")
            if default == 1:
                self.init_all_tables()

            year = self.ui.te_year_selection.text()
            mont_index = self.ui.cbox_month.currentIndex()+1
            if mont_index == 12:
                date_filter = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{int(year)+1}-{1}-1 00:00:00#"
            else:
                date_filter = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{year}-{mont_index+1}-1 00:00:00#"
            SQL_query = f"SELECT Jmeno,Prijmeni,SAVED_DATE,EDIT,STAV,SAVED_TIME FROM logs WHERE TAG = '{self.current_TAG}' {date_filter} AND EDIT <> 'SMAZÁNO' ORDER BY SAVED_DATE ASC, SAVED_TIME;"

            #print(SQL_query)

            query_dict = self.getQueryContent(SQL_query,0)
            table_update_dict = create_dictionary_for_table_widget(query_dict,int(mont_index),int(year))


            self.createAndUpdateTable(self.ui.table_attendance,table_update_dict,0)
            self.readFromPreviousMonth()
            self.readFromVyplatit()
            self.formatTable(self.ui.table_attendance)
            self.selectEmployee(item=self.ui.table_selection.currentItem())


        def getLastLogID(self):
            query = "SELECT LOG_ID from logs WHERE EDIT <> 'NONE'"
            self.ACCES.WriteQuery(query)
            result = self.ACCES.ResultFromQuery()
            max_log_id = 0
            for LOG_IDs in result:
                ID = int(LOG_IDs[0].replace("E", ""))
                if max_log_id < ID:
                    max_log_id = ID
            return max_log_id

        def init_all_tables(self, default = 0):
            self.employees_dict.clear()
            year = self.ui.te_year_selection.text()
            mont_index = self.ui.cbox_month.currentIndex()+1
            if mont_index == 12:
                date_filter = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{int(year)+1}-{1}-1 00:00:00#"
            else:
                date_filter = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{year}-{mont_index+1}-1 00:00:00#"
        
            #print(self.ui.table_selection.rowCount())
            for rows in range(self.ui.table_selection.rowCount()):
                TAG = self.ui.table_selection.item(rows,0).text()
                self.current_Jmeno = self.ui.table_selection.item(rows,1).text()
                self.current_Prijmeni = self.ui.table_selection.item(rows,2).text()
                SQL_query = f"SELECT Jmeno,Prijmeni,STAV,SAVED_TIME,SAVED_DATE,EDIT FROM logs WHERE TAG = '{TAG}' {date_filter} AND EDIT <> 'SMAZÁNO'  ORDER BY SAVED_DATE ASC, SAVED_TIME;"
                query_dict = self.getQueryContent(SQL_query,0)
                table_update_dict = create_dictionary_for_table_widget(query_dict,int(mont_index),int(year))
                self.readFromPreviousMonth()
                self.readFromVyplatit()
                self.createAndUpdateTable(self.ui.table_attendance,table_update_dict,0)
                self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"] = EachDay(self.number_of_days_in_current_month).employeeTimes
                fault_flag,hours = self.formatTable(self.ui.table_attendance)
                #print(f"{TAG} fault flag: {fault_flag}")

                if fault_flag == 1:
                    for columns in range(self.ui.table_selection.rowCount()):
                        if self.ui.table_selection.item(rows,columns) != None:
                            self.ui.table_selection.item(rows,columns).setBackground(QtGui.QColor(200,100,100,200))
                            self.ui.table_selection.item(rows,columns).setForeground(QtGui.QColor(55,55,55))
                else:
                    for columns in range(self.ui.table_selection.rowCount()):
                        if self.ui.table_selection.item(rows,columns) != None:
                            self.ui.table_selection.item(rows,columns).setBackground(QtGui.QColor(62, 62, 62))
                            self.ui.table_selection.item(rows,columns).setForeground(QtGui.QColor(141, 204, 169))

                self.employees_dict.append({"Jméno:":self.current_Jmeno,"Příjmenní":self.current_Prijmeni,\
                    "Normální doba": self.global_ov.normal,"Dovolená":self.global_ov.holliday,"Lékař":self.global_ov.doctor,\
                        "Nemocenská":self.global_ov.sick_days,"Pracovní Cesty":self.global_ov.work_rides,"Pochůzky":self.global_ov.short_work_rides,\
                            "Přesčasy":self.global_ov.overtime,"Počet Obědů": self.global_ov.meals,"Celkový čas":self.global_ov.overall_hour, "Počet Chyb": self.global_ov.faults})

                self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"] = {}
                self.makeSummary()
                self.savePplToPickle()

            with open(f"employee_summary_dict_{self.ui.cbox_month.currentText()}.pkl","wb") as f:
                pickle.dump(self.employee_summary_dict,f)
                f.close()
            if default == 1:
                self.selectEmployee(item=self.ui.table_selection.item(0,1))
            
            
        def makeSummary(self):
            celkovy_cas_bez_obedu = datetime.timedelta(seconds=0)
            for day in self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"]:
                for times in self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][day]:
                    if times == "Celkem bez obědů":
                        if self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][day][times] == "CHYBA":
                            continue
                        celkovy_cas_bez_obedu += self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][day][times]
            
            time_with_prevod = celkovy_cas_bez_obedu + datetime.timedelta(hours = float(self.ui.la_transfer_last_month_num.text().replace(",",".")))

            self.ui.la_transfer_current_month_num.setText(f"{time_with_prevod.total_seconds() / 3600:.2f}h")
            prescas_time = float(self.ui.la_transfer_current_month_num.text().replace("h","")) - float(self.ui.la_ov_time_plan_hour.text().replace("h",""))
            self.ui.la_ov_overtime.setText(f"{prescas_time:0.2f}h ({self.timeDeltaToHours(datetime.timedelta(hours=prescas_time))})")
            la_ov_overtime_to_count = f"{prescas_time:0.2f}h"

            self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"] = {}
            self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"]["Časový plán"] = self.ui.la_ov_time_plan_hour.text()
            self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"]["Prevod z minulého měsíce"] = self.ui.la_transfer_last_month_num.text()
            self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"]["Prevod do dalšího měsíce"] = self.ui.te_transfer_next_month.toPlainText()
            self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"]["Celkový přesčas"] = self.ui.la_ov_overtime.text()
            self.employee_summary_dict[f"{self.current_Jmeno} {self.current_Prijmeni}"]["Vyplatit"] = self.ui.te_pay_next_month.toPlainText()

        def selectEmployee(self,item):
            self.number_of_days_in_current_month = monthrange(int(self.ui.te_year_selection.text()),self.ui.cbox_month.currentIndex()+1)[1]
            year = self.ui.te_year_selection.text()
            mont_index = self.ui.cbox_month.currentIndex()+1
            if mont_index == 12:
                date_filter = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{int(year)+1}-{1}-1 00:00:00#"
            else:
                date_filter = f"AND SAVED_DATE >= #{year}-{mont_index}-1 00:00:00# AND SAVED_DATE <= #{year}-{mont_index+1}-1 00:00:00#"

            if self.sender() == None:
                self.ui.table_selection.setCurrentCell(0,1)
                self.current_TAG = self.ui.table_selection.item(0,0).text()
                self.current_Jmeno = self.ui.table_selection.item(0,1).text()
                self.current_Prijmeni = self.ui.table_selection.item(0,2).text()
                self.ui.la_selected_employee.setText(f"{self.ui.table_selection.item(0,1).text()} {self.ui.table_selection.item(0,2).text()}")
            else:
                self.current_TAG = self.ui.table_selection.item(item.row(),0).text()
                self.current_Jmeno = self.ui.table_selection.item(item.row(),1).text()
                self.current_Prijmeni = self.ui.table_selection.item(item.row(),2).text()
                self.ui.la_selected_employee.setText(f"{self.ui.table_selection.item(item.row(),1).text()} {self.ui.table_selection.item(item.row(),2).text()}")


            print(f"SELECTED EMPLOYEEEEEEE ::: {self.current_Jmeno} {self.current_Prijmeni}")
            
            SQL_query = f"SELECT Jmeno,Prijmeni,SAVED_DATE,EDIT,STAV,SAVED_TIME FROM logs WHERE TAG = '{self.current_TAG}' {date_filter} AND EDIT <> 'SMAZÁNO' ORDER BY SAVED_DATE ASC, SAVED_TIME;"
            query_dict = self.getQueryContent(SQL_query,0)
            self.readFromPreviousMonth()
            self.readFromVyplatit()
            table_update_dict = create_dictionary_for_table_widget(query_dict,int(mont_index),int(year))
            self.createAndUpdateTable(self.ui.table_attendance,table_update_dict,0)
            self.formatTable(self.ui.table_attendance)
            
            with open(f"employee_summary_dict_{self.ui.cbox_month.currentText()}.pkl","wb") as f:
                pickle.dump(self.employee_summary_dict,f)
                f.close()
            #self.savePplToPickle()
            
        def createAndUpdateTable(self,table_widget: QtWidgets.QTableWidget,SQL_query,database_index: int,append_write: str = "WRITE"):
            #p.pprint(SQL_query)
            current_horizontal_header_list = []
            LogHeader = []
            n_of_rows = 0
            column_offset = 0
            row_offset = 0
            for i in range(table_widget.columnCount()):
                #print(i)
                #print(table_widget.horizontalHeaderItem(i).text())
                res = table_widget.horizontalHeaderItem(i).text()
                current_horizontal_header_list.append(res)

            if type(SQL_query) == dict:
                dict_of_columns_query_result = SQL_query
            else:
                dict_of_columns_query_result= self.getQueryContent(SQL_query,database_index)
                
            if append_write == "WRITE":
                row_offset = 0
                column_offset = 0
                table_widget.clear()
                for keys in dict_of_columns_query_result:
                    if n_of_rows < len(dict_of_columns_query_result[keys]):      
                        n_of_rows = len(dict_of_columns_query_result[keys])   
                    LogHeader.append(keys)
                    

            elif append_write == "APPEND_ROWS":
                row_offset = table_widget.rowCount()
                column_offset = 0
                LogHeader = current_horizontal_header_list  
                for keys in dict_of_columns_query_result:
                    if n_of_rows < len(dict_of_columns_query_result[keys]):      
                        n_of_rows = len(dict_of_columns_query_result[keys])


                
            elif append_write == "APPEND_COLLUMNS":
                row_offset = 0
                column_offset = table_widget.columnCount()
                #print(f"list before{current_horizontal_header_list}")
                for keys in dict_of_columns_query_result:
                    current_horizontal_header_list.append(str(keys))
                    if table_widget.rowCount() < len(dict_of_columns_query_result[keys]):      
                        n_of_rows = len(dict_of_columns_query_result[keys])
                    else:
                        n_of_rows = table_widget.rowCount()
                #print(f"list after{current_horizontal_header_list}")
                LogHeader = current_horizontal_header_list.copy()
                
            elif append_write == "APPEND_ALL":
                row_offset = table_widget.rowCount()
                #print(f"before{column_offset}")
                column_offset = table_widget.columnCount()
                #print(f"after{column_offset}")
                for keys in dict_of_columns_query_result:
                    current_horizontal_header_list.append(str(keys))
                    if n_of_rows < len(dict_of_columns_query_result[keys]):      
                        n_of_rows = len(dict_of_columns_query_result[keys])
                LogHeader = current_horizontal_header_list


            if table_widget == self.ui.table_selection:
                iterable = dict_of_columns_query_result
                table_widget.setColumnCount(len(LogHeader))
                table_widget.setHorizontalHeaderLabels(LogHeader)#Fill Headers with predefined values

            else:
                iterable = LogHeader
                
                #print(LogHeader)
                try:
                    iterable.remove("SAVED_DATE")
                    iterable.remove("EDIT")
                    iterable.remove("GEN_DATE")
                    #iterable = ["GEN_DATE"]+ ["SAVED_DATE"] + ["EDIT"]  + iterable
                    iterable = ["GEN_DATE"] + iterable
                    table_widget.setColumnCount(len(iterable))
                    table_widget.setHorizontalHeaderLabels(iterable)#Fill Headers with predefined values
                except:
                    #print("DEXIST")
                    table_widget.setColumnCount(len(iterable))
                    table_widget.setHorizontalHeaderLabels(iterable)#Fill Headers with predefined values
                
            #print(f"logHEADER before set : {LogHeader}")
            
            table_widget.setRowCount(row_offset + n_of_rows )
            
            col_number = 0

            
            
            #print(iterable)
            
            for columns_keys in iterable: #for all rows from query
                
                #print(f"column key:{columns_keys}")
                row_number = 0
                for row_in_column in dict_of_columns_query_result[columns_keys]: #for all columns in row
                    if (columns_keys.find("SAVED_TIME") > -1 and row_in_column != None):
                        date_time_obj = datetime.datetime.strptime(row_in_column,"#%Y-%m-%d %H:%M:%S#")
                        
                        row_in_column = datetime.datetime.strftime(date_time_obj,"%H:%M:%S")
                        #print(f"{date_time_obj.ctime()} vs {row_in_column}")
                    if (columns_keys.find("SAVED_DATE") > -1 and row_in_column != None):
                        date_time_obj = datetime.datetime.strptime(row_in_column,"#%Y-%m-%d %H:%M:%S#")
                        row_in_column = datetime.datetime.strftime(date_time_obj,"%d.%m.%Y")
                    #print(f"row_ in column :{row_in_column}")
                    Item = QtWidgets.QTableWidgetItem(str(row_in_column).replace("'",""))#To update table, it is necessary to create QTableWidgetItem for each cell
                    #print(f"updating table: row:{row_number+row_offset} col:{col_number+column_offset} Item:{Item.text()}")
                    self.current_cell_column = column_offset+col_number
                    self.current_cell_row = row_offset+row_number
                    table_widget.setItem(row_offset+row_number,column_offset+col_number,Item)         
                    row_number += 1
                col_number += 1

        def formatTable(self,table_widget:QtWidgets.QTableWidget):

            #headers = [table_widget.horizontalHeaderItem(c).text() for c in range(table_widget.columnCount())]
            #print(f"FORMATING HEADER {headers}")
            self.global_ov.resetAll()
            fault_flag_to_return = 0
            self.list_of_all_widgets_cboxes = []
            self.list_of_all_widgets_times = []

            day = 0
            for rows in range(table_widget.rowCount()):
                day += 1
                hours = {"Odchod": datetime.timedelta(),
                "Doktor": datetime.timedelta(),
                "Obed" : datetime.timedelta(),
                "Prac Cesta" : datetime.timedelta(),
                "Dovolena" : datetime.timedelta(),
                "Nemoc" : datetime.timedelta(),
                "Pochuzka" : datetime.timedelta(),
                "Jine" : datetime.timedelta(),
                "Oml Abs" : datetime.timedelta(),
                "CELKEM" : datetime.timedelta(),
                }

                fault_flag = 0
                ignore_today_flag = 0
                no_paint_flag = 0 # no paint background of cell
                pre_flag = 0 #does previous state match pattern ?
                if table_widget.item(rows,1) != None:
                    #No working days
                    if (table_widget.item(rows,0).text().find("So") > -1) or (table_widget.item(rows,0).text().find("Ne") > -1) or (table_widget.item(rows,0).text().find("svátek") > -1):
                        for columns in range(table_widget.columnCount()):
                            if table_widget.item(rows, columns) != None:
                                if table_widget.horizontalHeaderItem(int(columns)).text().find("STAV") > -1:
                                    nested_cbox = comboCompanies(self,table_widget)
                                    date_widget = dateSelector(self,table_widget)
                                    table_widget.setCellWidget(rows, columns, nested_cbox)
                                    self.list_of_all_widgets_cboxes.append(nested_cbox)
                                    table_widget.setCellWidget(rows, columns+1, date_widget) #INSERT widget for updating time into coresponding cell
                                    self.list_of_all_widgets_times.append(date_widget)
                        no_paint_flag = 1



                    else:
                        #WORKING DAY
                        if self.current_TAG in self.YAML["POLOVICNI_UVAZKY"]:
                            add_time = datetime.timedelta(hours=4)
                        else:
                            add_time = datetime.timedelta(hours=8)

                        self.global_ov.time_plan_hours += add_time
                        for columns in range(table_widget.columnCount()):
                            if table_widget.item(rows, columns) != None:#if item exists (record is present)
                                table_widget.item(rows, columns).setBackground(QtGui.QColor(120,220,120,180)) #print it green
                                table_widget.item(rows,columns).setForeground(QtGui.QColor(55,55,55))

                    if table_widget.item(rows,1).text() == "None" and no_paint_flag == 0: #there is no record and it is working day
                        if table_widget.item(rows, columns) != None:
                            alternate_time = True
                            for columns in range(table_widget.columnCount()):
                                table_widget.item(rows, columns).setBackground(QtGui.QColor(220,120,120,20)) #print it bright red
                                table_widget.item(rows,columns).setForeground(QtGui.QColor(141, 204, 169))
                                if table_widget.horizontalHeaderItem(int(columns)).text().find("STAV") > -1:
                                    alternate_time = not alternate_time 
                                    nested_cbox = comboCompanies(self,table_widget)
                                    date_widget = dateSelector(self,table_widget)
                                            
                                    
                                    if alternate_time:
                                        if self.current_TAG in self.YAML["POLOVICNI_UVAZKY"]:
                                            date_widget.setTime(QTime(11,0,0))
                                        else:
                                            date_widget.setTime(QTime(15,30,0))
                                        nested_cbox.setCurrentText("Odchod")
                                    else:
                                        date_widget.setTime(QTime(7,0,0)) # take time of cell
                                        nested_cbox.setCurrentText("Prichod")
                                        

                                    table_widget.setCellWidget(rows, columns, nested_cbox)
                                    self.list_of_all_widgets_cboxes.append(nested_cbox)
                                    table_widget.setCellWidget(rows, columns+1, date_widget) #INSERT widget for updating time into coresponding cell
                                    self.list_of_all_widgets_times.append(date_widget)
                    
                    elif table_widget.item(rows,1).text() != "None": #there is record
                        if table_widget.item(rows, columns) != None: #item exists
                            num_of_IN_STATES = 0 #IN and out must be same at the end of day
                            num_of_OUT_STATES = 0 #IN and out must be same at the end of day
                            previous_STATE = "OUT" #STATES should be IN, OUT, IN, OUT , etc.. checking previous state later.. Wanted first state is IN therefore previous state = OUT
                            for columns in range(table_widget.columnCount()):
                                if table_widget.horizontalHeaderItem(int(columns)).text().find("STAV") > -1:
                                    if table_widget.item(rows, columns).text() != 'None': # if record for STAV exists
                                        to_compare = table_widget.item(rows, columns).text() # Prichod, Odchod, Doktor, etc

                                        #formating of string time to insert dateSelector widget into SAVED_TIME cells
                                        coresponding_time = datetime.datetime.strptime(table_widget.item(rows, columns+1).text(),"%H:%M:%S")#next column corresponds to time
                                        date_widget = dateSelector(self,table_widget)
                                        date_widget.setTime(QTime(coresponding_time.hour,coresponding_time.minute,coresponding_time.second)) # take time of cell
                                        table_widget.setCellWidget(rows, columns+1, date_widget) #INSERT widget for updating time into coresponding cell
                                        self.list_of_all_widgets_times.append(date_widget)
                                        time_to_delta = datetime.timedelta(hours=coresponding_time.hour,minutes=coresponding_time.minute,seconds=coresponding_time.second)

                                        nested_cbox = comboCompanies(self,table_widget)
                                        nested_cbox.setCurrentText(table_widget.item(rows, columns).text())
                                        table_widget.setCellWidget(rows, columns, nested_cbox)
                                        self.list_of_all_widgets_cboxes.append(nested_cbox)
                                        table_widget.item(rows, columns).setForeground(QtGui.QColor(0,0,0,0))#transaprent
                                        table_widget.item(rows, columns+1).setForeground(QtGui.QColor(0,0,0,0))#transaprent

                                        if (self.dict_of_STAV[to_compare] == "IN"):
                                            num_of_IN_STATES += 1
                                            #hours["Odchod"] -= time_to_delta

                                        elif self.dict_of_STAV[to_compare] == "SMAZÁNO":
                                            ...

                                        elif self.dict_of_STAV[to_compare] == "SPECIAL":
                                            ...

                                        else:
                                            num_of_OUT_STATES += 1
                                            #hours["Odchod"] += time_to_delta

                                        if num_of_IN_STATES != num_of_OUT_STATES:
                                            fault_flag = 1
                                        else:
                                            fault_flag = 0

                                        if to_compare == "Prac Cesta" or to_compare == "Doktor":
                                            try:
                                                table_text = table_widget.item(rows, columns+3).text()
                                                print(table_text, "WWWWWWWWWWWWWWWWWWWWWWWWWW") #there is Prac Cesta out, but does next Prichod Exist?
                                                if table_text == "None":
                                                    fault_flag = 1
                                            except:
                                                fault_flag = 1

                                        if previous_STATE == self.dict_of_STAV[to_compare]:
                                            pre_flag = 1

                                        previous_STATE = self.dict_of_STAV[to_compare]

                                    else:
                                        nested_cbox = comboCompanies(self,table_widget)
                                        nested_cbox.setCurrentText(table_widget.item(rows, columns).text())
                                        table_widget.setCellWidget(rows, columns, nested_cbox)
                                        self.list_of_all_widgets_cboxes.append(nested_cbox)
                                        date_widget = dateSelector(self,table_widget)
                                        date_widget.setTime(QTime(9,0,0)) # take time of cell
                                        table_widget.setCellWidget(rows, columns+1, date_widget) #INSERT widget for updating time into coresponding cell
                                        self.list_of_all_widgets_times.append(date_widget)
                                        table_widget.item(rows, columns).setBackground(QtGui.QColor(220,120,120,20)) #print it bright red
                                        table_widget.item(rows, columns+1).setBackground(QtGui.QColor(220,120,120,20)) #print it bright red



                    #datetime.datetime.now().strftime("%d.%m.%Y"): #if date == today ignore fault
                    if table_widget.item(rows,0).text()[3:14] == datetime.datetime.now().strftime("%d.%m.%Y"):
                        fault_flag = 0
                        ignore_today_flag = 1


                    if fault_flag == 1 or pre_flag == 1:
                        fault_flag_to_return = 1
                        for columns in range(table_widget.columnCount()):
                            if table_widget.horizontalHeaderItem(int(columns)).text().find("STAV") == -1:
                                if table_widget.item(rows, columns) != None:
                                    if table_widget.horizontalHeaderItem(int(columns)).text().find("SAVED_TIME") > -1:
                                        table_widget.item(rows,columns).setForeground(QtGui.QColor(0,0,0,0))
                                        if table_widget.item(rows,columns).text() != "None":
                                            table_widget.item(rows, columns).setBackground(QtGui.QColor(200,100,100,200))
                                    else:
                                        table_widget.item(rows, columns).setBackground(QtGui.QColor(200,100,100,200))
                                        table_widget.item(rows,columns).setForeground(QtGui.QColor(55,55,55))
                                    
                                
                            else:
                                if table_widget.item(rows, columns) != None:
                                    table_widget.item(rows, columns).setBackground(QtGui.QColor(200,100,100,200))
                                    table_widget.item(rows,columns).setForeground(QtGui.QColor(0,0,0,0))
                                
                                    
                                    if table_widget.item(rows,columns).text() == "None":
                                        #print("IM IN ELSE")
                                        nested_cbox = comboCompanies(self,table_widget)
                                        nested_cbox.setCurrentText(table_widget.item(rows, columns).text())
                                        table_widget.setCellWidget(rows, columns, nested_cbox)
                                        self.list_of_all_widgets_cboxes.append(nested_cbox)

                                        date_widget = dateSelector(self,table_widget)
                                        date_widget.setTime(QTime(0,0,0)) # take time of cell
                                        table_widget.setCellWidget(rows, columns+1, date_widget) #INSERT widget for updating time into coresponding cell
                                        self.list_of_all_widgets_times.append(date_widget)
                                        table_widget.item(rows, columns).setBackground(QtGui.QColor(220,120,120,20)) #print it bright red
                                        table_widget.item(rows, columns+1).setBackground(QtGui.QColor(220,120,120,20)) #print it bright red
                    else:

                        text_to_add = table_widget.item(rows,0).text()
                        prichod_time =  datetime.timedelta()
                        out_time = datetime.timedelta()
                        curent_time = "CELKEM"
                        ignore_next_odchod = 0
                        for columns in range(table_widget.columnCount()):
                            if table_widget.horizontalHeaderItem(int(columns)).text().find("STAV") > -1:
                                if table_widget.item(rows,columns+1).text() != "None":
                                    if "Prichod" in table_widget.item(rows,columns).text():
                                        (h, m, s) = table_widget.item(rows,columns+1).text().split(":")
                                        prichod_time = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))

                                    elif "Nemoc" in table_widget.item(rows,columns).text():
                                        if self.current_TAG in self.YAML["POLOVICNI_UVAZKY"]:
                                            hours["Nemoc"] +=  datetime.timedelta(hours=4, minutes=0, seconds=0)
                                        else:
                                            hours["Nemoc"] +=  datetime.timedelta(hours=8, minutes=0, seconds=0)
                                    
                                    elif "Oml Abs" in table_widget.item(rows,columns).text():
                                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Oml Abs"] = 1

                                    elif "Jine" in table_widget.item(rows,columns).text():
                                        if self.current_TAG in self.YAML["POLOVICNI_UVAZKY"]:
                                            hours["Nemoc"] +=  datetime.timedelta(hours=4, minutes=0, seconds=0)
                                        else:
                                            hours["Jine"] +=  datetime.timedelta(hours=8, minutes=0, seconds=0)
                                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Jine"] +=  datetime.timedelta(hours=8, minutes=0, seconds=0)

                                    elif "Dovolena" in table_widget.item(rows,columns).text():
                                        if self.current_TAG in self.YAML["POLOVICNI_UVAZKY"]:
                                            hours["Nemoc"] +=  datetime.timedelta(hours=4, minutes=0, seconds=0)
                                        else:
                                            hours["Dovolena"] +=  datetime.timedelta(hours=8, minutes=0, seconds=0)
                                        
                                    elif "Prac Cesta" in table_widget.item(rows,columns).text():
                                        (h, m, s) = table_widget.item(rows,columns-1).text().split(":")
                                        last_prichod = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
                                        (h, m, s) = table_widget.item(rows,columns+1).text().split(":")
                                        prac_cesta = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))

                                        hours["Odchod"] = prac_cesta - last_prichod
                                    
                                        try:
                                            (h, m, s) = table_widget.item(rows,columns+3).text().split(":")
                                            prichod_z_cesty = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
                                        except:
                                            print(f"ERROR: prichod_z_cesty {self.current_Jmeno} {self.current_Prijmeni} {day}")
                                            #exit()

                                        if (prichod_z_cesty - prichod_time).seconds/3600 > self.ui.te_cnt_short_walks.value():
                                            hours["Prac Cesta"] +=  prichod_z_cesty - prac_cesta
                                        else:
                                            hours["Pochuzka"] +=  prichod_z_cesty - prac_cesta 

                                    elif "Doktor" in table_widget.item(rows,columns).text():
                                        (h, m, s) = table_widget.item(rows,columns-1).text().split(":")
                                        last_prichod = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
                                        (h, m, s) = table_widget.item(rows,columns+1).text().split(":")
                                        doktor = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))

                                        hours["Odchod"] = doktor - last_prichod
                                        

                                        try:
                                            (h, m, s) = table_widget.item(rows,columns+3).text().split(":")
                                            prichod_od_doktora = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
                                            hours["Doktor"] +=  prichod_od_doktora - doktor
                                        except:
                                            print(f"ERROR: Doktor {self.current_Jmeno} {self.current_Prijmeni} {day}")
                                            #exit()

                                        

                                    else:
                                        #print(table_widget.item(rows,columns+1).text())
                                        (h, m, s) = table_widget.item(rows,columns+1).text().split(":")
                                        odchod_time = datetime.timedelta(hours=int(h), minutes=int(m), seconds=int(s))
                                        hours[table_widget.item(rows,columns).text()] +=  odchod_time - prichod_time
                                        curent_time = table_widget.item(rows,columns).text()

                                    text_to_add += f" {table_widget.item(rows,columns).text()}"
                        #print(f"{text_to_add}, {hours[curent_time]} ")

                        self.global_ov.doctor += hours['Doktor']
                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Doktor"] = hours['Doktor']
                        self.global_ov.work_rides += hours['Prac Cesta']
                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Prac Cesta"] = hours['Prac Cesta']
                        self.global_ov.sick_days += hours['Nemoc']
                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Nemoc"] = hours['Nemoc']
                        self.global_ov.normal += hours["Odchod"]
                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Normalni Doba"] = hours['Odchod']
                        self.global_ov.holliday += hours["Dovolena"]
                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Dovolena"] = hours['Dovolena']
                        self.global_ov.short_work_rides += hours["Pochuzka"]
                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Pochuzka"] = hours['Pochuzka']

                        for keys in hours:
                            if keys != "CELKEM":
                                hours["CELKEM"] += hours[keys]

                        self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem s obědy"] = hours["CELKEM"]


                        
                        
                        
                for columns in range(table_widget.columnCount()):
                    if table_widget.item(rows, columns) != None:
                        if table_widget.item(rows, columns).text() == "None":
                            table_widget.item(rows, columns).setText("")
                                
                #table_widget.item(rows,table_widget.columnCount()-1).setText(f"{(datetime.datetime.min + hours['CELKEM']).time()}")
                if fault_flag == 1 or pre_flag == 1:
                    table_widget.item(rows,table_widget.columnCount()-1).setText(f"CHYBA")
                    self.ui.la_ov_overall_time_hours.setText(f"CHYBA")
                    self.global_ov.faults += 1
                    self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem s obědy"] = "CHYBA"
                    self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem bez obědů"] = "CHYBA"
                else:
                    if ignore_today_flag == 0:
                        if (hours["CELKEM"].seconds/3600  - hours["Nemoc"].seconds/3600  - hours["Dovolena"].seconds/3600 - hours["Jine"].seconds/3600 ) > self.ui.te_cnt_meals.value():
                            self.global_ov.meals += 1
                            self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Oběd"] = 1
                            self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem bez obědů"]\
                                =self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem s obědy"] - datetime.timedelta(hours=0.5)
                        else:
                            self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Oběd"] = 0
                            self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem bez obědů"] = self.hours_in_day[f"{self.current_Jmeno} {self.current_Prijmeni}"][f"{day}"]["Celkem s obědy"]

                        table_widget.item(rows,table_widget.columnCount()-1).setText(f"{hours['CELKEM']}")
                        self.global_ov.overall_hour += hours["CELKEM"]
                    
            self.ui.la_ov_overall_time_hours.setText(f"{self.global_ov.overall_hour.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_overall_time_days.setText(f"{ self.global_ov.overall_hour.total_seconds()/3600/8.5:0.2f}dní")
            

            
            self.ui.la_ov_doctor_hours.setText(f"{self.global_ov.doctor.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_doctor_days.setText( f"{self.global_ov.doctor.total_seconds()/3600/8.5:0.2f}dní")

            self.ui.la_ov_work_rides_hours.setText(f"{self.global_ov.work_rides.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_work_rides_days.setText( f"{self.global_ov.work_rides.total_seconds()/3600/8.5:0.2f}dní")

            self.ui.la_ov_short_work_rides_hours.setText(f"{self.global_ov.short_work_rides.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_short_work_rides_days.setText( f"{self.global_ov.short_work_rides.total_seconds()/3600/8.5:0.2f}dní")

            self.ui.la_ov_sick_days_hours.setText(f"{self.global_ov.sick_days.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_sick_days_days.setText( f"{self.global_ov.sick_days.total_seconds()/3600/8.5:0.2f}dní")

            self.ui.la_ov_normal_hours.setText(f"{self.global_ov.normal.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_normal_days.setText( f"{self.global_ov.normal.total_seconds()/3600/8.5:0.2f}dní")

            self.ui.la_ov_time_plan_hour.setText(f"{self.global_ov.time_plan_hours.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_time_plan_days.setText( f"{self.global_ov.time_plan_hours.total_seconds()/3600/8:0.2f}dní")

            self.ui.la_ov_holliday_hours.setText(f"{self.global_ov.holliday.total_seconds()/3600:0.2f}h")
            self.ui.la_ov_holliday_days.setText( f"{self.global_ov.holliday.total_seconds()/3600/8.5:0.2f}dní")

            self.ui.la_ov_meals_value.setText(f"{self.global_ov.meals} obědů")
            self.ui.la_ov_faults_value.setText(f"{self.global_ov.faults}")

            self.makeSummary()

            #p.pprint(self.hours_in_day)
            return fault_flag_to_return, hours
        
        def initStyles(self):
            """nothing special just styling, CSS, alignment, creating lists of UIs for future usage... """

            self.setWindowTitle("Docházkový systém")
            self.ui.table_attendance.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents) 
            self.ui.table_selection.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)  
            #self.ui.table_attendance.verticalHeader().setSectionResizeMode(0,  QHeaderView.ResizeMode.ResizeToContents)
            self.list_of_small_static_labels = [
                self.ui.la_add_first_name,
                self.ui.la_add_second_name,
                self.ui.la_month_selection,
                self.ui.la_date_time,
                self.ui.la_last_log_ID_db,
                self.ui.la_last_log_ID_SD,
                self.ui.la_transfer_current_month,
                self.ui.la_transfer_from_last_month,
                self.ui.la_transfer_to_pay,
                self.ui.la_transfer_to_next_month,
                self.ui.la_old_PW,
                self.ui.la_new_PW,
                self.ui.la_ov_doctor,
                self.ui.la_ov_faults,
                self.ui.la_ov_holliday,
                self.ui.la_ov_meals,
                self.ui.la_ov_normal,
                self.ui.la_ov_overall_time,
                self.ui.la_ov_short_work_rides,
                self.ui.la_ov_sick_days,
                self.ui.la_ov_work_rides,
                self.ui.la_ov_time_plan,
                self.ui.la_year_selection,
                self.ui.la_cnt_meals,
                self.ui.la_cnt_short_walks,
                self.ui.la_ov_overtime_label,
                self.ui.la_static_selected_employee,

            ]

            self.list_of_small_dynamic_labels = [
                self.ui.la_date_time_value,
                self.ui.la_transfer_current_month_num,
                self.ui.la_transfer_last_month_num,
                self.ui.la_last_log_ID_db_value,
                self.ui.la_last_log_ID_SD_value,
                self.ui.la_selected_employee,
                self.ui.la_selected_sound,
                self.ui.la_ov_doctor_hours,
                self.ui.la_ov_holliday_hours,
                self.ui.la_ov_normal_hours,
                self.ui.la_ov_overall_time_hours,
                self.ui.la_ov_short_work_rides_hours,
                self.ui.la_ov_sick_days_hours,
                self.ui.la_ov_work_rides_hours,
                self.ui.la_ov_doctor_days,
                self.ui.la_ov_holliday_days,
                self.ui.la_ov_normal_days,
                self.ui.la_ov_overall_time_days,
                self.ui.la_ov_short_work_rides_days,
                self.ui.la_ov_sick_days_days,
                self.ui.la_ov_work_rides_days,
                self.ui.la_ov_overtime,
                self.ui.la_ov_meals_value,
                self.ui.la_ov_faults_value,
                self.ui.la_ov_time_plan_hour,
                self.ui.la_ov_time_plan_days,
                
            ]

            self.list_of_big_static_labels = [
                self.ui.la_overview_header,
                self.ui.la_permissions,
                self.ui.la_add_employee,
                self.ui.la_PW,
                self.ui.la_transfer,
                self.ui.la_db_SD_sync,
                self.ui.la_SD_card,
                self.ui.la_local_db,
                self.ui.la_print,
                self.ui.la_detailed_attendance,
                self.ui.la_employee_selection_header
            ]

            self.list_of_buttons = [
                self.ui.pb_add_reccord,
                self.ui.pb_change_PW,
                self.ui.pb_download_to_db_from_SD,
                self.ui.pb_print_selected,
                self.ui.pb_refresh,
                self.ui.pb_scan_tag,
                self.ui.pb_make_excell_anomalies,
                self.ui.pb_make_excell_attendance,
                self.ui.pb_scan_tag,
                self.ui.pb_sync_date,
                self.ui.pb_transfer_pay,
                self.ui.pb_sound,
                self.ui.pb_make_changes,
                self.ui.pb_save_hour_settings
            ]

            self.list_of_textedits = [
                self.ui.te_first_name,
                self.ui.te_second_name,
                self.ui.te_new_pw,
                self.ui.te_old_pw,
                self.ui.te_pay_next_month,
                self.ui.te_transfer_next_month,
                self.ui.te_year_selection,
            ]

            self.list_of_tables = [
                self.ui.table_attendance,
                self.ui.table_selection,
                self.ui.table_souhrn
            ]
            self.list_of_date_edits = [
                #self.ui.date_add,
            ]

            self.list_checkboxes = [
                self.ui.che_Permissions_modify,
                self.ui.che_Permissions_entry,
                self.ui.che_Permissions_SD_modify,
                self.ui.che_Permissions_view_web,

                
            ]

            self.list_of_spin_boxes= [
                self.ui.te_cnt_meals,
                self.ui.te_cnt_short_walks,
            ]

            for te in self.list_of_spin_boxes:
                te.setMinimumHeight(28)
                
                te.setStyleSheet("""
                                font-size:10pt;
                                color: rgb(141, 204, 169);
                                background-color:rgb(85, 85, 85);
                                border-top: 3px solid rgb(30,30, 30);
                                border-left: 3px solid rgb(30,30, 30);
                                border-bottom: 1px solid rgb(30,30, 30);
                                border-right: 1px solid rgb(30,30, 30);    
                                """)

            self.ui.tabWidget.setStyleSheet(
                """
                    QTabBar::tab:selected {background: rgb(51, 168, 25);}
                    QTabBar::tab:!selected {background: grey;}
                    QTabWidget>QWidget>QWidget {background:  rgb(104, 104, 104);}
                    QTabWidget::pane { border: 2px solid black;}         
                """
            )
            self.ui.tabWidget.tabBar().setMinimumWidth(300)
            self.ui.tabWidget.setTabText(0,"Docházka")
            self.ui.tabWidget.setTabText(1,"Anomálie")
            self.ui.tabWidget.setTabText(2,"Souhrn")

            for checkboxes in self.list_checkboxes:
                checkboxes.setStyleSheet("""                                    
                                        QCheckBox:enabled
                                        {
                                        font-size:10pt;
                                        color: rgb(141, 204, 169); 
                                        font-weight: bold; 
                                        }"""
                                        )

        #self.ui.tree_SD.setStyleSheet("""
        #        font-size:10pt;
        #        color: rgb(141, 204, 169);
        #        background-color:rgb(85, 85, 85);
        #        border-top: 3px solid rgb(30,30, 30);
        #        border-left: 3px solid rgb(30,30, 30);
        #        border-bottom: 1px solid rgb(30,30, 30);
        #        border-right: 1px solid rgb(30,30, 30);    
        #        """)
        #
        #self.ui.tree_SD.header().setStyleSheet("""
        #                    QHeaderView::section {
        #                            background-color:rgba(51, 168, 25,0.6);

        #                    }
        #                    """)

            self.ui.cbox_month.setStyleSheet("""
                    font-size:10pt;
                    color: rgb(141, 204, 169);
                    background-color:rgb(85, 85, 85);
                    border-top: 3px solid rgb(30,30, 30);
                    border-left: 3px solid rgb(30,30, 30);
                    border-bottom: 1px solid rgb(30,30, 30);
                    border-right: 1px solid rgb(30,30, 30);    
                    """)
            self.ui.cbox_month.setMinimumWidth(180)
            self.ui.cbox_month.setCurrentIndex(datetime.datetime.now().month-1)


            for dates in self.list_of_date_edits:
                dates.setStyleSheet("""
                    font-size:10pt;
                    color: rgb(141, 204, 169);
                    background-color:rgb(85, 85, 85);
                    border-top: 3px solid rgb(30,30, 30);
                    border-left: 3px solid rgb(30,30, 30);
                    border-bottom: 1px solid rgb(30,30, 30);
                    border-right: 1px solid rgb(30,30, 30);    
                    """)
                dates.setMinimumHeight(25)
                dates.setMinimumWidth(160)
                my_day = datetime.datetime.now().date().day
                my_month = datetime.datetime.now().date().month
                my_year = datetime.datetime.now().date().year
                
                dates.setDate(QDate(my_year,my_month,my_day))  

            for te in self.list_of_textedits:
                te.setMinimumHeight(28)
                
                te.setStyleSheet("""
                                font-size:10pt;
                                color: rgb(141, 204, 169);
                                background-color:rgb(85, 85, 85);
                                border-top: 3px solid rgb(30,30, 30);
                                border-left: 3px solid rgb(30,30, 30);
                                border-bottom: 1px solid rgb(30,30, 30);
                                border-right: 1px solid rgb(30,30, 30);    
                                """)
            self.ui.te_year_selection.setText(str(datetime.datetime.now().year))

            for tables in self.list_of_tables:
                tables.setStyleSheet(""" 
                                        border: none;
                                        color: rgb(141, 204, 169);
                                        background-color: rgb(62, 62, 62);
                                        selection-color: rgb(62, 62, 62);
                                        selection-background-color: rgb(62, 222, 62);
                                        gridline-color: rgba(151, 210, 170,0.4);
                                        """)  
                tables.horizontalHeader().setStyleSheet("""QHeaderView::section
                                                        {
                                                        background-color:rgba(51, 168, 25,0.6);
                                                        border: 2px solid black;
                                                        font-size:12px;
                                                        }
                                                            """)
                for columns in range(0,tables.columnCount()):
                    delegate = AlignDelegate(tables)
                    tables.setItemDelegateForColumn(columns, delegate)
                tables.setRowCount(0)

            for labels in self.list_of_small_static_labels:
                labels.setStyleSheet("""background: rgba(255, 255, 255, 0);
                                        color: rgb(141, 204, 169);
                                        font-size: 10pt;
                                        font-weight: bold;
                                        """)

            for labels in self.list_of_small_dynamic_labels:
                labels.setStyleSheet("""background: rgba(255, 255, 255, 0);
                                        color:rgb(51, 168, 25);
                                        font-size: 10pt;
                                        font-weight: bold;
                                        """)
                if labels == self.ui.la_selected_employee:
                    labels.setStyleSheet("""background: rgba(255, 255, 255, 0);
                            color:black;
                            font-size: 12pt;
                            font-weight: bold;
                            """)
                if labels == self.ui.la_date_time_value:
                    labels.setStyleSheet("""background: rgba(255, 255, 255, 0);
                                color:black;
                                font-size: 18pt;
                                font-weight: bold;
                                """)

            for labels in self.list_of_big_static_labels:
                labels.setStyleSheet("""background: rgba(255, 255, 255, 0);
                                        color:rgb(51, 168, 25);
                                        font-size: 12pt;
                                        font-weight: bold;""")
            
            for buttons in self.list_of_buttons:
                #buttons.setStyleSheet("background: qlineargradient( x1:0 y1:0, x2:1 y2:1, stop:0  rgb(104, 100, 222) , stop:1 rgb(83, 232, 255))")
                buttons.setMinimumHeight(25)
                buttons.setMinimumWidth(120)

                buttons.setStyleSheet("""	QPushButton:!pressed
                                            {
                                            font-size:9pt;
                                            border-top: 1px solid rgb(30,30, 30);
                                            border-left: 1px solid rgb(30,30, 30);
                                            border-bottom: 3px solid rgb(30,30, 30);
                                            border-right: 3px solid rgb(30,30, 30);
                                            
                                            color: rgb(141, 204, 169);
                                            background-color:rgb(85, 85, 85);
                                            
                                            }

                                            QPushButton::pressed{
                                            font-size:9pt;
                                            color: rgb(34, 113, 17);
                                            background-color:rgb(85, 85, 85);
                                            border-top: 3px solid rgb(30,30, 30);
                                            border-left: 3px solid rgb(30,30, 30);
                                            border-bottom: 1px solid rgb(30,30, 30);
                                            border-right: 1px solid rgb(30,30, 30);
                                            }

                                            QPushButton::disabled
                                            {
                                            background-color:rgb(71, 71, 71);
                                            }""")

        def getQueryContent(self,query, cursor_index):
            dict_of_columns = {}
            self.ACCES.MultipleWriteQuery(query,[cursor_index])
            description = self.ACCES.cursors[cursor_index].description
            result = self.ACCES.MultipleResultFromQuery([cursor_index])
            for rows in description:
                dict_of_columns[rows[0]] = []

            for rows in result:
                i = 0
                for columns in rows:
                    if str(description[i][1]) == "<class 'int'>" and columns != None:
                        dict_of_columns[description[i][0]].append(str(columns))
                    
                    elif str(description[i][1]) == "<class 'datetime.datetime'>" and columns != None:
                        dict_of_columns[description[i][0]].append( "#"  + str(columns) + "#")

                    elif str(description[i][1]) == "<class 'str'>" and columns != None:
                        columns = str(columns).replace("'","''")
                        dict_of_columns[description[i][0]].append( "'"  + str(columns) + "'")

                    elif str(description[i][1]) == "<class 'decimal.Decimal'>" and columns != None:
                        dict_of_columns[description[i][0]].append( str(columns))
                    
                    elif str(description[i][1]) == "<class 'float'>" and columns != None:
                        dict_of_columns[description[i][0]].append( str(columns))
                    
                    elif str(description[i][1]) == "<class 'int'>" and columns != None:
                        dict_of_columns[description[i][0]].append(str(columns))

                    elif str(description[i][1]) == "<class 'bool'>" and columns != None:
                        if columns == True:
                            dict_of_columns[description[i][0]].append("True")
                        else:
                            dict_of_columns[description[i][0]].append("False")

                    elif columns == None:
                        dict_of_columns[description[i][0]].append( "NULL")
                    
                    else:
                        dict_of_columns[description[i][0]].append( "'"  + str(columns) + "'")

                    i += 1
            return dict_of_columns

        #    return dates

    class comboCompanies(QComboBox):
        def __init__(self, parent,table_widget:QTableWidget):
            super().__init__(parent)
            self.setStyleSheet("""

            QComboBox{
                            font-size:10pt;
                            font-weight: bold;
                            color: rgb(30, 30, 30);
                            background-color:rgba(120,220,120,0); 
            }


            QComboBox::down-arrow{
                image:                  color: rgb(30, 30, 30);
                background-color:rgba(120,220,120,0); 
            }
            
            QComboBox::drop-down{
                            font-size:10pt;
                            font-weight: bold;
                            color: rgb(30, 30, 30);
                            background-color:rgba(120,220,120,1); 
            }

            """)
            self.table_attendance = table_widget
            self.update_flag = 0
            self.addItems(['Prichod', 'Odchod', 'Doktor', 'Prac Cesta', 'Obed', 'Nemoc', 'Dovolena', 'Oml Abs', 'Jine', 'SMAZAT'])
            self.signalsBlocked()
            self.setWindowOpacity(1)
            self.activated.connect(self.getComboValue)
            #self.currentIndexChanged.connect(self.getComboValue)


        def showPopup(self):
            self.setStyleSheet("""

            QComboBox{
                            font-size:10pt;
                            font-weight: bold;
                            color: rgb(30, 30, 30);
                            background-color:rgba(240, 169, 29,1);  
            }
            
            """)
            self.repaint()
            super().showPopup()
            
        def getComboValue(self):
            #row = self.table_attendance.currentRow()
            #column = self.table_attendance.currentColumn()
            self.table_attendance.currentItem().setSelected(False)
            cell_text =  self.table_attendance.currentItem().text()
            widget_text = self.table_attendance.cellWidget(self.table_attendance.\
                currentItem().row(),self.table_attendance.currentItem().column()).currentText()
            self.row = self.table_attendance.currentRow()
            self.column = self.table_attendance.currentColumn()

            self.setStyleSheet("""
            
                QComboBox::item:selected
                {
                    background-color: rgb(0, 0, 255);
                    color: rgb(0, 0, 0);
                }"""
                )
            

            
            if cell_text != widget_text:
                self.update_flag = 1
                self.setStyleSheet("""

                QComboBox{
                                font-size:10pt;
                                font-weight: bold;
                                color: rgb(30, 30, 30);
                                background-color:rgba(240, 169, 29,1); 
                }

                QComboBox::down-arrow{
                    image:                  color: rgb(30, 30, 30);
                    background-color:rgba(120,220,120,0); 
                }
                QComboBox::drop-down{
                                font-size:10pt;
                                font-weight: bold;
                                color: rgb(30, 30, 30);
                                background-color:rgba(120,220,120,1); 
                }

                QComboBox::item:selected
                {
                    background-color: rgb(0, 0, 255);
                    color: rgb(0, 0, 0);
                }

                """)
            else:
                self.update_flag = 0
                self.setStyleSheet("""

                QComboBox{
                                font-size:10pt;
                                font-weight: bold;
                                color: rgb(30, 30, 30);
                                background-color:rgba(120,220,120,0); 
                }

                QComboBox::down-arrow{
                    image:                  color: rgb(30, 30, 30);
                    background-color:rgba(120,220,120,0); 
                }
                QComboBox::drop-down{
                                font-size:10pt;
                                font-weight: bold;
                                color: rgb(30, 30, 30);
                                background-color:rgba(120,220,120,1); 
                }
                
                QComboBox::item:selected
                {
                    background-color: rgb(0, 0, 255);
                    color: rgb(0, 0, 0);
                }

                """)

    class dateSelector(QDateTimeEdit):
        def __init__(self, parent,table_widget:QTableWidget):
            super().__init__(parent)
            self.setStyleSheet("""

            QDateTimeEdit
            {
            font-size:10pt;
                font-weight: bold;
                color: rgb(30, 30, 30);
                background-color:rgba(120,220,120,0); 
            }
            """)
            self.table_attendance = table_widget
            self.timeChanged.connect(self.getDateValue)
            self.setDisplayFormat("hh:mm:ss")
            self.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
            self.installEventFilter(self)
            self.lineEdit().installEventFilter(self)


            self.update_flag = 0
            #self.currentIndexChanged.connect(self.getComboValue)

        def eventFilter(self, obj, event):
            if obj ==  self.lineEdit() or obj == self:
                if event.type() == QtCore.QEvent.MouseButtonPress:
                    self.setStyleSheet("""
                            QDateTimeEdit
                        {
                        font-size:10pt;
                            font-weight: bold;
                            color: rgb(30, 30, 30);
                            background-color:rgba(240, 169, 29,1); 
                        }
                        """)
                    self.repaint()
            
                    print("Mouse release event")

            return super(QDateTimeEdit,self).eventFilter(obj, event)

        def changeStyle(self):

            print("CALLBACK")
            self.setStyleSheet("""
            QDateTimeEdit
            {
            font-size:10pt;
                font-weight: bold;
                color: rgb(30, 30, 30);
                background-color:rgba(240, 169, 29,1); 
            }
            """)

        def unselect(self):
            self.table_attendance.currentItem().setSelected(False)

        def getDateValue(self):
            if self.table_attendance.currentItem() != None:
                self.row = self.table_attendance.currentRow()
                self.column = self.table_attendance.currentColumn()
                self.table_attendance.currentItem().setSelected(False)
                #print(f"{self.time().toString()} vs {self.table_attendance.currentItem().text()}")
                if self.time().toString() != self.table_attendance.currentItem().text():
                    self.update_flag = 1
                    self.setStyleSheet("""
                        QDateTimeEdit
                        {
                        font-size:10pt;
                            font-weight: bold;
                            color: rgb(30, 30, 30);
                            background-color:rgb(240, 169, 29); 
                        }
                        """)
                else:
                    self.update_flag = 0
                    self.setStyleSheet("""
                        QDateTimeEdit
                        {
                        font-size:10pt;
                            font-weight: bold;
                            color: rgb(30, 30, 30);
                            background-color:rgba(120,220,120,0); 
                        }
                        """)


    if __name__ == '__main__':
        #Read config file:

        app = QtWidgets.QApplication([])
        MainWindow = MainWindowApp()
        #MainWindow.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        MainWindow.show() 
            # return self.currentText()
        #MainWindow.showMaximized()
        #self.showFullScreen()
        app.exec_()
    
except Exception as e:
    with open("error.log","w") as f:
        exception_str = traceback.format_exc()
        print(exception_str)
        f.write(exception_str)




